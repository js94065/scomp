package scomp;

import java.util.*;

import java_cup.runtime.*;


parser code 
{:

/*
public void report_error(String message, Object info) {

	if(message.equals("Syntax error")) {
		
		if(((Symbol)info).sym == 0) {
			System.err.println(((Symbol)info).sym);
		}
		else {
			System.err.println("Syntax Error '" + ((DecafToken)(info)).getInputString() + 
			"' at (" + ((DecafToken)info).getRow() + "," + ((DecafToken)info).getColumn() + ")");
		}
		
	}
}
*/
:}

terminal BOOLEAN, BREAK, CALLOUT, CLASS, CONTINUE, ELSE, IF, INT, RETURN, VOID, WHILE;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_BRACE, RIGHT_BRACE, LEFT_BRACKET, RIGHT_BRACKET;
terminal ASSIGN; // "=", not to be confused with "=="  which is EQUAL
terminal COMMA, SEMI_COLON, NOT, PLUS, MINUS, TIMES, DIVIDE, MODULO;
terminal ARITHMETIC_SHIFT_LEFT, ARITHMETIC_SHIFT_RIGHT, BITWISE_ROTATE_RIGHT;
terminal LESSER, GREATER, LESSER_OR_EQUAL, GREATER_OR_EQUAL, EQUAL, NOT_EQUAL, AND, OR;
terminal INT_LITERAL;
terminal BOOLEAN_LITERAL;
terminal CHAR_LITERAL;
terminal STRING_LITERAL;
terminal String IDENTIFIER;

non terminal Program Program;
non terminal List FieldDeclarations;
non terminal List FieldDeclaration;
non terminal List Fields;
non terminal String Field;
non terminal List MethodDeclarations;
non terminal MethodDeclaration MethodDeclaration;
non terminal List ParameterDeclarations;
non terminal FieldDeclaration ParameterDeclaration;
non terminal List VariableDeclarations;
non terminal List IdentifierList;
non terminal List Statements;
non terminal Statement Statement;
non terminal Block Block;
non terminal Class Type;
non terminal MethodCall MethodCall;
non terminal Location Location;
non terminal List Exprs;
non terminal Expr Expr;
non terminal CalloutArgs, CalloutArg;
non terminal Literal;
non terminal BinOp, ArithOp, RelOp, EqOp, CondOp;

precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LESSER, GREATER, LESSER_OR_EQUAL, GREATER_OR_EQUAL;
precedence left ARITHMETIC_SHIFT_LEFT, ARITHMETIC_SHIFT_RIGHT, BITWISE_ROTATE_RIGHT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO;
precedence left NOT;

Program ::=
	CLASS IDENTIFIER LEFT_BRACE RIGHT_BRACE
	{:
		RESULT = new Program(null, null);
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE FieldDeclarations:fieldDeclarations RIGHT_BRACE
	{:
		RESULT = new Program(fieldDeclarations, null);
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE MethodDeclarations:methodDeclarations RIGHT_BRACE
	{:
		RESULT = new Program(null, methodDeclarations);
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE FieldDeclarations:fieldDeclarations MethodDeclarations:methodDeclarations RIGHT_BRACE
	{:
		RESULT = new Program(fieldDeclarations, methodDeclarations);
	:}
	|
	// Missing code
	{:
		final Yylex scanner = (Yylex) this.parser.getScanner();
		
		if (scanner != null) {
			throw new RuntimeException("(:" + scanner.getCurrentRow() + ":" + scanner.getCurrentColumn() + ") Parse error");
		}
	:}
	|
	CLASS // Missing "Program" identifier
	{:
		final DecafToken lastToken = (DecafToken) CUP$DecafParser$stack.elementAt(CUP$DecafParser$top - 0);
		
		if (lastToken != null) {
			throw new RuntimeException("(:" + lastToken.getRow() + ":" + lastToken.getColumn() + ") Parse error");
		}
	:}
	|
	// missing LEFT_BRACE
	CLASS IDENTIFIER 
	{:
		final DecafToken lastToken = Tools.cast(DecafToken.class, CUP$DecafParser$stack.elementAt(CUP$DecafParser$top - 0));
		
		if (lastToken != null) {
			throw new RuntimeException("(:" + lastToken.getRow() + ":" + lastToken.getColumn() + ") Unmatched '}'");
		}
	:}
	|
	// missing RIGHT_BRACE 
	CLASS IDENTIFIER LEFT_BRACE 
	{:
		final DecafToken lastToken = Tools.cast(DecafToken.class, CUP$DecafParser$stack.elementAt(CUP$DecafParser$top - 0));
		
		if (lastToken != null) {
			throw new RuntimeException("(:" + lastToken.getRow() + ":" + lastToken.getColumn() + ") Missing '}'");
		}
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE FieldDeclarations
	{:
		final DecafToken lastToken = Tools.cast(DecafToken.class, CUP$DecafParser$stack.elementAt(CUP$DecafParser$top - 0));
		
		if (lastToken != null) {
			throw new RuntimeException("(:" + lastToken.getRow() + ":" + lastToken.getColumn() + ") Missing '}'");
		}
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE MethodDeclarations
	{:
		final DecafToken lastToken = Tools.cast(DecafToken.class, CUP$DecafParser$stack.elementAt(CUP$DecafParser$top - 0));
		
		if (lastToken != null) {
			throw new RuntimeException("(:" + lastToken.getRow() + ":" + lastToken.getColumn() + ") Missing '}'");
		}
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE FieldDeclarations MethodDeclarations
	{:
		final DecafToken lastToken = Tools.cast(DecafToken.class, CUP$DecafParser$stack.elementAt(CUP$DecafParser$top - 0));
		
		if (lastToken != null) {
			throw new RuntimeException("(:" + lastToken.getRow() + ":" + lastToken.getColumn() + ") Missing '}'");
		}
	:}
	;

FieldDeclarations ::=
	FieldDeclarations:fieldDeclarations FieldDeclaration:fieldDeclaration
	{:
		RESULT = new ArrayList<FieldDeclaration>(fieldDeclarations);
		
		RESULT.addAll(fieldDeclaration);
	:}
	|
	FieldDeclaration:fieldDeclaration
	{:
		RESULT = new ArrayList<FieldDeclaration>(fieldDeclaration);
	:}
	;

FieldDeclaration ::=
	Type:type Fields:fields SEMI_COLON
	{:
		RESULT = new ArrayList<FieldDeclaration>();
		
		for (final Object field : fields) {
			final String[] fieldElements = ((String) field).split(" ");
			
			switch (fieldElements.length) {
			case 1:
				RESULT.add(new FieldDeclaration(type, fieldElements[0]));
				break;
			case 2:
				RESULT.add(new ArrayFieldDeclaration(type, fieldElements[0], Integer.parseInt(fieldElements[1])));
				break;
			default:
				throw new IllegalArgumentException("" + field);
			}
		}
	:}
	;

Fields ::=
	Fields:fields COMMA Field:field
	{:
		RESULT = new ArrayList<String>(fields);
		
		RESULT.add(field);
	:}
	|
	Field:field
	{:
		RESULT = new ArrayList<String>();
		
		RESULT.add(field);
	:}
	/*
	|
	Fields COMMA error // missing Field
	|
	error COMMA Field // missing Fields
	|
	error Field // missing COMMA
	*/
	;

Field ::=
	IDENTIFIER:identifier
	{:
		RESULT = identifier;
	:}
	|
	IDENTIFIER:identifier LEFT_BRACKET INT_LITERAL:elementCount RIGHT_BRACKET
	{:
		RESULT = identifier + " " + elementCount;
	:}
	|
	error LEFT_BRACKET INT_LITERAL RIGHT_BRACKET // missing IDENTIFIER
	|
	IDENTIFIER error INT_LITERAL RIGHT_BRACKET // missing LEFT_BRACKET
	|
	IDENTIFIER LEFT_BRACKET error RIGHT_BRACKET // missing INT_LITERAL
	|
	IDENTIFIER LEFT_BRACKET INT_LITERAL error // missing RIGHT_BRACKET
	;

MethodDeclarations ::=
	MethodDeclarations:methodDeclarations MethodDeclaration:methodDeclaration
	{:
		RESULT = new ArrayList<Object>(methodDeclarations);
		RESULT.add(methodDeclaration);
	:}
	|
	MethodDeclaration:methodDeclaration
	{:
		RESULT = new ArrayList<Object>();
		RESULT.add(methodDeclaration);
	:}
	;

MethodDeclaration ::=
	Type:type IDENTIFIER:identifier LEFT_PARENTHESIS RIGHT_PARENTHESIS Block:block 
	{:
		RESULT = new MethodDeclaration(type, identifier, null, block);
	:}
	|
	VOID IDENTIFIER:identifier LEFT_PARENTHESIS RIGHT_PARENTHESIS Block:block 
	{:
		RESULT = new MethodDeclaration(void.class, identifier, null, block);
	:}
	|
	Type:type IDENTIFIER:identifier LEFT_PARENTHESIS ParameterDeclarations:parameterDeclarations RIGHT_PARENTHESIS Block:block 
	{:
		RESULT = new MethodDeclaration(type, identifier, parameterDeclarations, block);
	:}
	|
	VOID IDENTIFIER:identifier LEFT_PARENTHESIS ParameterDeclarations:parameterDeclarations RIGHT_PARENTHESIS Block:block
	{:
		RESULT = new MethodDeclaration(void.class, identifier, parameterDeclarations, block);
	:}
	/*
	|
	// missing Type or VOID
	error IDENTIFIER LEFT_PARENTHESIS RIGHT_PARENTHESIS Block 
	|
	error IDENTIFIER LEFT_PARENTHESIS ParameterDeclarations RIGHT_PARENTHESIS Block
	|
	// missing IDENTIFIER
	Type error LEFT_PARENTHESIS RIGHT_PARENTHESIS Block 
	|
	VOID error LEFT_PARENTHESIS RIGHT_PARENTHESIS Block
	|
	Type error LEFT_PARENTHESIS ParameterDeclarations RIGHT_PARENTHESIS Block
	|
	VOID error LEFT_PARENTHESIS ParameterDeclarations RIGHT_PARENTHESIS Block
	|
	// missing LEFT_PARENTHESIS
	Type IDENTIFIER error RIGHT_PARENTHESIS Block
	|
	VOID IDENTIFIER error RIGHT_PARENTHESIS Block
	|
	Type IDENTIFIER error ParameterDeclarations RIGHT_PARENTHESIS Block
	|
	VOID IDENTIFIER error ParameterDeclarations RIGHT_PARENTHESIS Block
	|
	// missing RIGHT_PARENTHESIS
	Type IDENTIFIER LEFT_PARENTHESIS error Block
	|
	VOID IDENTIFIER LEFT_PARENTHESIS error Block
	|
	Type IDENTIFIER LEFT_PARENTHESIS ParameterDeclarations error Block
	|
	VOID IDENTIFIER LEFT_PARENTHESIS ParameterDeclarations error Block
	|
	// missing Block
	Type IDENTIFIER LEFT_PARENTHESIS RIGHT_PARENTHESIS error
	|
	VOID IDENTIFIER LEFT_PARENTHESIS RIGHT_PARENTHESIS error
	|
	Type IDENTIFIER LEFT_PARENTHESIS ParameterDeclarations RIGHT_PARENTHESIS error
	|
	VOID IDENTIFIER LEFT_PARENTHESIS ParameterDeclarations RIGHT_PARENTHESIS error
	*/
	;
	
ParameterDeclarations ::= 
	ParameterDeclaration:parameterDeclaration
	{:
		RESULT = new ArrayList<FieldDeclaration>();
		
		RESULT.add(parameterDeclaration);
	:}
	|
	ParameterDeclarations:parameterDeclarations COMMA ParameterDeclaration:parameterDeclaration
	{:
		RESULT = new ArrayList<FieldDeclaration>(parameterDeclarations);
		
		RESULT.add(parameterDeclaration);
	:}
	/*
	|
	ParameterDeclarations COMMA error // missing ParameterDeclaration
	|
	error COMMA ParameterDeclaration // missing ParameterDeclarations
	|
	error ParameterDeclaration // missing COMMA
	*/
	;
	
ParameterDeclaration ::=
	Type:type IDENTIFIER:identifier
	{:
		RESULT = new FieldDeclaration(type, identifier);
	:}
	/*
	|
	Type error // missing IDENTIFIER
	|
	error IDENTIFIER // missing Type
	*/
	;

Block ::=
	LEFT_BRACE RIGHT_BRACE
	|
	LEFT_BRACE VariableDeclarations:variableDeclarations RIGHT_BRACE
	{:
		RESULT = new Block(variableDeclarations, null);
	:}
	|
	LEFT_BRACE Statements:statements RIGHT_BRACE
	{:
		RESULT = new Block(null, statements);
	:}
	|
	LEFT_BRACE VariableDeclarations:variableDeclarations Statements:statements RIGHT_BRACE
	{:
		RESULT = new Block(variableDeclarations, statements);
	:}
	/*
	|
	// missing LEFT_BRACE
	error RIGHT_BRACE
	|
	error VariableDeclarations RIGHT_BRACE
	|
	error Statements RIGHT_BRACE
	|
	error VariableDeclarations Statements RIGHT_BRACE
	|
	// missing RIGHT_BRACE
	LEFT_BRACE error
	|
	LEFT_BRACE VariableDeclarations error
	|
	LEFT_BRACE Statements error
	|
	LEFT_BRACE VariableDeclarations Statements error
	*/
	;
	
VariableDeclarations ::=
	Type:type IdentifierList:identifierList SEMI_COLON
	{:
		RESULT = new ArrayList<FieldDeclaration>();
		
		for (final Object identifier : identifierList) {
			RESULT.add(new VariableDeclaration(type, (String) identifier));
		}

	:}
	|
	VariableDeclarations:variableDeclarations Type:type IdentifierList:identifierList SEMI_COLON
	{:
		RESULT = new ArrayList<VariableDeclaration>(variableDeclarations);
		
		for (final Object identifier : identifierList) {
			RESULT.add(new VariableDeclaration(type, (String) identifier));
		}
		
	:}
	;
	
IdentifierList  ::=
	IDENTIFIER:identifier
	{:
		RESULT = new ArrayList<String>();
		
		RESULT.add(identifier);
	:}
	|
	IdentifierList:identifierList COMMA IDENTIFIER:identifier
	{:
		RESULT = new ArrayList<String>(identifierList);
		
		RESULT.add(identifier);
	:}
	;

Type ::=
	INT
	{:
		RESULT = int.class;
	:}
	|
	BOOLEAN
	{:
		RESULT = boolean.class;
	:}
	;
	
Statements ::=
	Statement:statement
	{:
		RESULT = new ArrayList<Statement>();
		
		RESULT.add(statement);
	:}
	|
	Statements:statements Statement:statement
	{:
		RESULT = new ArrayList<Statement>(statements);
		
		RESULT.add(statement);
	:}
	;

Statement ::=
	Location:location ASSIGN Expr:expr SEMI_COLON
	{:
		RESULT = new StatementLocation(location, expr);
	:}
	|
	MethodCall:methodCall SEMI_COLON
	{:
		RESULT = new StatementMethodCall(methodCall);
	:}
	|
	IF LEFT_PARENTHESIS Expr:expr RIGHT_PARENTHESIS Block:block
	{:
		RESULT = new StatementIf(expr, block, null);
	:}
	|
	IF LEFT_PARENTHESIS Expr:expr RIGHT_PARENTHESIS Block:ifBlock ELSE Block:elseBlock
	{:
		RESULT = new StatementIf(expr, ifBlock, elseBlock);
	:}
	|
	WHILE LEFT_PARENTHESIS Expr:expr RIGHT_PARENTHESIS Block:block
	{:
		RESULT = new StatementWhile(expr, block);
	:}
	|
	RETURN SEMI_COLON
	{:
		RESULT = new StatementReturn(null);
	:}
	|
	RETURN Expr:expr SEMI_COLON
	{:
		RESULT = new StatementReturn(expr);
	:}
	|
	BREAK SEMI_COLON
	{:
		RESULT = new StatementBreak();
	:}
	|
	CONTINUE SEMI_COLON
	{:
		RESULT = new StatementContinue();
	:}
	|
	Block:block
	{:
		RESULT = new StatementBlock(block);
	:}
	;
	
MethodCall ::= 
	IDENTIFIER:identifier LEFT_PARENTHESIS RIGHT_PARENTHESIS
	{:
		RESULT = new MethodName(identifier,null);
	:}
	|
	IDENTIFIER:identifier LEFT_PARENTHESIS Exprs:exprs RIGHT_PARENTHESIS
	{:
		RESULT = new MethodName(identifier, exprs);
	:}
	|
	CALLOUT LEFT_PARENTHESIS STRING_LITERAL:stringLiteral RIGHT_PARENTHESIS
	{:
		RESULT = new MethodCallout((String)stringLiteral,null);
	:}
	|
	CALLOUT LEFT_PARENTHESIS STRING_LITERAL:stringLiteral COMMA CalloutArgs:calloutArgs RIGHT_PARENTHESIS
	{:
	//	RESULT = new MethodCallout((String)stringLiteral,calloutArgs);
	:}
	;

CalloutArgs ::=
	CalloutArg:calloutArg
	{:
	//	RESULT = new ArrayList<CalloutArgument>(calloutArg);
	:}
	|
	CalloutArgs:calloutArgs COMMA CalloutArg:calloutArg
	{:
	//	RESULT = new ArrayList<CalloutArgument>(calloutArgs);
		
	//	RESULT.addAll(calloutArg);
	:}
	;
	
CalloutArg ::=
	Expr
	|
	STRING_LITERAL
	;

Location ::=
	IDENTIFIER
	|
	IDENTIFIER LEFT_BRACKET Expr RIGHT_BRACKET
	;
	
Exprs ::=
	Expr
	|
	Exprs COMMA Expr
	;
	
Expr ::=
	Location
	|
	MethodCall
	|
	Literal
	|
	Expr BinOp Expr
	|
	MINUS Expr
	|
	NOT Expr
	|
	LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
	;

BinOp ::=
	ArithOp
	|
	RelOp
	|
	EqOp
	|
	CondOp
	;

ArithOp ::=
	PLUS
	|
	MINUS
	|
	TIMES
	|
	DIVIDE
	|
	MODULO
	|
	ARITHMETIC_SHIFT_LEFT
	|
	ARITHMETIC_SHIFT_RIGHT
	|
	BITWISE_ROTATE_RIGHT
	;

RelOp ::=
	LESSER
	|
	GREATER
	|
	LESSER_OR_EQUAL
	|
	GREATER_OR_EQUAL
	;
	
EqOp ::=
	EQUAL
	|
	NOT_EQUAL
	;

CondOp ::=
	AND
	|
	OR
	;
	
Literal ::=
	INT_LITERAL
	|
	BOOLEAN_LITERAL
	|
	CHAR_LITERAL
	;

