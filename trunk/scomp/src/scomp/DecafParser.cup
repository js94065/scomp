package scomp;

import java.util.*;
import java.util.logging.*;

import java_cup.runtime.*;


parser code
{:
	
	private final Logger logger = Logger.getLogger(DecafParser.class.getName());
	
	private List<String> errors = new ArrayList<String>();
	
	/**
	 * @return
	 * <br>Not null
	 * <br>Shared
	 */
	public final List<String> getErrors() {
		return this.errors;
	}
	
	/**
	 * @param message
	 * <br>Maybe null
	 */
	public final void logError(final String message) {
		this.getErrors().add(message);
		this.logger.log(Level.SEVERE, message);
	}
	
	/**
	 * @return
	 * <br>Range: any boolean
	 */
	public final boolean hasErrors() {
		return !this.getErrors().isEmpty();
	}
	
	/**
	 * @return
	 * <br>Maybe null
	 * <br>Shared
	 */
	public final Symbol getStackTop() {
		return (Symbol) this.stack.peek();
	}
	
	@Override
	public final void report_error(final String message, final Object info) {
		Tools.debugPrint(message, info);
	}
	
	@Override
	public final void report_fatal_error(final String message, final Object info) {
		Tools.debugPrint(message, info);
	}
	
	@Override
	public final void syntax_error(final Symbol currentToken) {
		Tools.debugPrint(currentToken);
		Tools.debugPrint(this.stack);
		
		final Yylex scanner = (Yylex) this.getScanner();
		
		scanner.updateLocation();
		
		int row = scanner.getCurrentRow();
		int column = scanner.getCurrentColumn();
		String errorMessage = "Parse error";
		
		for (final Object symbol : this.stack) {
			switch (((Symbol) symbol).sym) {
			case DecafParserSymbols.LEFT_PARENTHESIS:
				errorMessage = "Missing \")\"";
				break;
			case DecafParserSymbols.LEFT_BRACE:
				errorMessage = "Missing \"}\"";
				break;
			case DecafParserSymbols.LEFT_BRACKET:
				errorMessage = "Missing \"]\"";
				break;
			default:
				break;
			}
		}
		
		final DecafToken token = Tools.cast(DecafToken.class, currentToken);
		
		if (token != null) {
			row = token.getRow();
			column = token.getColumn();
			
			errorMessage = "Unexpected \"" + token.getInputString() + "\"";
		}
		
		this.logError("(:" + row + ":" + column + ") " + errorMessage);
	}
	
	@Override
	public final void unrecovered_syntax_error(final Symbol currentToken) throws Exception {
		Tools.debugPrint(currentToken);
		throw new RuntimeException(this.getErrors().toString());
	}
	
:}

action code
{:
	
	/**
	 * @return
	 * <br>Not null
	 * <br>Shared
	 */
	public final DecafParser getParser() {
		return this.parser;
	}
	
	/**
	 * @return
	 * <br>Maybe null
	 * <br>Shared
	 */
	public final Symbol getStackTop() {
		return this.getParser().getStackTop();
	}
	
	/**
	 * @param message
	 * <br>Maybe null
	 */
	public final void logError(final String message) {
		this.getParser().logError(message);
	}
	
	/**
	 * @param program
	 * <br>Maybe null
	 * @return {@code program} or {@code null} if there was an error
	 * <br>Maybe null
	 */
	public final Program nullIfErrors(final Program program) {
		return this.getParser().hasErrors() ? null : program;
	}
	
:}

terminal BOOLEAN, BREAK, CALLOUT, CLASS, CONTINUE, ELSE, IF, INT, RETURN, VOID, WHILE;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_BRACE, RIGHT_BRACE, LEFT_BRACKET, RIGHT_BRACKET;
terminal ASSIGN; // "=", not to be confused with "=="  which is EQUAL
terminal COMMA, SEMICOLON;
terminal String NOT, PLUS, MINUS, TIMES, DIVIDE, MODULO;
terminal String ARITHMETIC_SHIFT_LEFT, ARITHMETIC_SHIFT_RIGHT, BITWISE_ROTATE_RIGHT;
terminal String LESS, GREATER, LESS_OR_EQUAL, GREATER_OR_EQUAL, EQUAL, NOT_EQUAL, AND, OR;
terminal String INT_LITERAL;
terminal Boolean BOOLEAN_LITERAL;
terminal Character CHAR_LITERAL;
terminal String STRING_LITERAL;
terminal String IDENTIFIER;

non terminal Program Program;
non terminal List FieldDeclarations;
non terminal List FieldDeclaration;
non terminal List Fields;
non terminal String Field;
non terminal List MethodDeclarations;
non terminal MethodDeclaration MethodDeclaration;
non terminal List ParameterDeclarations;
non terminal ParameterDeclaration ParameterDeclaration;
non terminal List VariableDeclarations;
non terminal List IdentifierList;
non terminal List Statements;
non terminal AbstractStatement Statement;
non terminal Block Block;
non terminal Class Type;
non terminal AbstractMethodCall MethodCall;
non terminal AbstractLocation Location;
non terminal List Expressions;
non terminal AbstractExpression Expression;
non terminal AbstractCalloutArgument CalloutArg;
non terminal List CalloutArgs;
non terminal AbstractLiteral Literal;
non terminal String BinaryOperator, ArithmeticOperator, RelationOperator, EqualityOperator, ConditionalOperator;

precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LESS, GREATER, LESS_OR_EQUAL, GREATER_OR_EQUAL;
precedence left ARITHMETIC_SHIFT_LEFT, ARITHMETIC_SHIFT_RIGHT, BITWISE_ROTATE_RIGHT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO;
precedence left NOT;

Program ::=
	CLASS IDENTIFIER LEFT_BRACE RIGHT_BRACE
	{:
		RESULT = this.nullIfErrors(new Program(null, null));
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE FieldDeclarations:fieldDeclarations RIGHT_BRACE
	{:
		RESULT = this.nullIfErrors(new Program(fieldDeclarations, null));
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE MethodDeclarations:methodDeclarations RIGHT_BRACE
	{:
		RESULT = this.nullIfErrors(new Program(null, methodDeclarations));
	:}
	|
	CLASS IDENTIFIER LEFT_BRACE FieldDeclarations:fieldDeclarations MethodDeclarations:methodDeclarations RIGHT_BRACE
	{:
		RESULT = this.nullIfErrors(new Program(fieldDeclarations, methodDeclarations));
	:}
	;

FieldDeclarations ::=
	FieldDeclarations:fieldDeclarations FieldDeclaration:fieldDeclaration
	{:
		RESULT = new ArrayList<FieldDeclaration>(fieldDeclarations);
		
		RESULT.addAll(fieldDeclaration);
	:}
	|
	FieldDeclaration:fieldDeclaration
	{:
		RESULT = new ArrayList<FieldDeclaration>(fieldDeclaration);
	:}
	;

FieldDeclaration ::=
	Type:type Fields:fields SEMICOLON
	{:
		RESULT = new ArrayList<FieldDeclaration>();
		
		for (final Object field : fields) {
			final String[] fieldElements = ((String) field).split(" ");
			
			switch (fieldElements.length) {
			case 1:
				RESULT.add(new FieldDeclaration(type, fieldElements[0]));
				break;
			case 2:
				RESULT.add(new ArrayFieldDeclaration(type, fieldElements[0], Integer.parseInt(fieldElements[1])));
				break;
			default:
				throw new IllegalArgumentException("" + field);
			}
		}
	:}
	;

Fields ::=
	Fields:fields COMMA Field:field
	{:
		RESULT = new ArrayList<String>(fields);
		
		RESULT.add(field);
	:}
	|
	Field:field
	{:
		RESULT = new ArrayList<String>();
		
		RESULT.add(field);
	:}
	;

Field ::=
	IDENTIFIER:identifier
	{:
		RESULT = identifier;
	:}
	|
	IDENTIFIER:identifier LEFT_BRACKET INT_LITERAL:elementCount RIGHT_BRACKET
	{:
		RESULT = identifier + " " + elementCount;
	:}
	;

MethodDeclarations ::=
	MethodDeclarations:methodDeclarations MethodDeclaration:methodDeclaration
	{:
		RESULT = new ArrayList<Object>(methodDeclarations);
		
		RESULT.add(methodDeclaration);
	:}
	|
	MethodDeclaration:methodDeclaration
	{:
		RESULT = new ArrayList<Object>();
		
		RESULT.add(methodDeclaration);
	:}
	;

MethodDeclaration ::=
	Type:type IDENTIFIER:identifier LEFT_PARENTHESIS RIGHT_PARENTHESIS Block:block 
	{:
		RESULT = new MethodDeclaration(type, identifier, null, block);
	:}
	|
	VOID IDENTIFIER:identifier LEFT_PARENTHESIS RIGHT_PARENTHESIS Block:block 
	{:
		RESULT = new MethodDeclaration(void.class, identifier, null, block);
	:}
	|
	Type:type IDENTIFIER:identifier LEFT_PARENTHESIS ParameterDeclarations:parameterDeclarations RIGHT_PARENTHESIS Block:block 
	{:
		RESULT = new MethodDeclaration(type, identifier, parameterDeclarations, block);
	:}
	|
	VOID IDENTIFIER:identifier LEFT_PARENTHESIS ParameterDeclarations:parameterDeclarations RIGHT_PARENTHESIS Block:block
	{:
		RESULT = new MethodDeclaration(void.class, identifier, parameterDeclarations, block);
	:}
	;
	
ParameterDeclarations ::= 
	ParameterDeclaration:parameterDeclaration
	{:
		RESULT = new ArrayList<ParameterDeclaration>();
		
		RESULT.add(parameterDeclaration);
	:}
	|
	ParameterDeclarations:parameterDeclarations COMMA ParameterDeclaration:parameterDeclaration
	{:
		RESULT = new ArrayList<ParameterDeclaration>(parameterDeclarations);
		
		RESULT.add(parameterDeclaration);
	:}
	;
	
ParameterDeclaration ::=
	Type:type IDENTIFIER:identifier
	{:
		RESULT = new ParameterDeclaration(type, identifier);
	:}
	;

Block ::=
	LEFT_BRACE RIGHT_BRACE
	{:
		RESULT = new Block(null, null);
	:}
	|
	LEFT_BRACE VariableDeclarations:variableDeclarations RIGHT_BRACE
	{:
		RESULT = new Block(variableDeclarations, null);
	:}
	|
	LEFT_BRACE Statements:statements RIGHT_BRACE
	{:
		RESULT = new Block(null, statements);
	:}
	|
	LEFT_BRACE VariableDeclarations:variableDeclarations Statements:statements RIGHT_BRACE
	{:
		RESULT = new Block(variableDeclarations, statements);
	:}
	;
	
VariableDeclarations ::=
	Type:type IdentifierList:identifierList SEMICOLON
	{:
		RESULT = new ArrayList<FieldDeclaration>();
		
		for (final Object identifier : identifierList) {
			RESULT.add(new VariableDeclaration(type, (String) identifier));
		}

	:}
	|
	VariableDeclarations:variableDeclarations Type:type IdentifierList:identifierList SEMICOLON
	{:
		RESULT = new ArrayList<VariableDeclaration>(variableDeclarations);
		
		for (final Object identifier : identifierList) {
			RESULT.add(new VariableDeclaration(type, (String) identifier));
		}
		
	:}
	;
	
IdentifierList  ::=
	IDENTIFIER:identifier
	{:
		RESULT = new ArrayList<String>();
		
		RESULT.add(identifier);
	:}
	|
	IdentifierList:identifierList COMMA IDENTIFIER:identifier
	{:
		RESULT = new ArrayList<String>(identifierList);
		
		RESULT.add(identifier);
	:}
	;

Type ::=
	INT
	{:
		RESULT = int.class;
	:}
	|
	BOOLEAN
	{:
		RESULT = boolean.class;
	:}
	;
	
Statements ::=
	Statement:statement
	{:
		RESULT = new ArrayList<AbstractStatement>();
		
		RESULT.add(statement);
	:}
	|
	Statements:statements Statement:statement
	{:
		RESULT = new ArrayList<AbstractStatement>(statements);
		
		RESULT.add(statement);
	:}
	;

Statement ::=
	Location:location ASSIGN Expression:expression SEMICOLON
	{:
		RESULT = new AssignmentStatement(location, expression);
	:}
	|
	MethodCall:methodCall SEMICOLON
	{:
		RESULT = new MethodCallStatement(methodCall);
	:}
	|
	IF LEFT_PARENTHESIS Expression:expression RIGHT_PARENTHESIS Block:block
	{:
		RESULT = new IfStatement(expression, block, null);
	:}
	|
	IF LEFT_PARENTHESIS Expression:expression RIGHT_PARENTHESIS Block:thenBlock ELSE Block:elseBlock
	{:
		RESULT = new IfStatement(expression, thenBlock, elseBlock);
	:}
	|
	WHILE LEFT_PARENTHESIS Expression:expression RIGHT_PARENTHESIS Block:block
	{:
		RESULT = new WhileStatement(expression, block);
	:}
	|
	RETURN SEMICOLON
	{:
		RESULT = new ReturnStatement(null);
	:}
	|
	RETURN Expression:expression SEMICOLON
	{:
		RESULT = new ReturnStatement(expression);
	:}
	|
	BREAK SEMICOLON
	{:
		RESULT = new BreakStatement();
	:}
	|
	CONTINUE SEMICOLON
	{:
		RESULT = new ContinueStatement();
	:}
	|
	Block:block
	{:
		RESULT = new BlockStatement(block);
	:}
	;
	
MethodCall ::= 
	IDENTIFIER:identifier LEFT_PARENTHESIS RIGHT_PARENTHESIS
	{:
		RESULT = new MethodCall(identifier, null);
	:}
	|
	IDENTIFIER:identifier LEFT_PARENTHESIS Expressions:expressions RIGHT_PARENTHESIS
	{:
		RESULT = new MethodCall(identifier, expressions);
	:}
	|
	CALLOUT LEFT_PARENTHESIS STRING_LITERAL:stringLiteral RIGHT_PARENTHESIS
	{:
		RESULT = new MethodCallout((String)stringLiteral, null);
	:}
	|
	CALLOUT LEFT_PARENTHESIS STRING_LITERAL:stringLiteral COMMA CalloutArgs:calloutArgs RIGHT_PARENTHESIS
	{:
		RESULT = new MethodCallout((String)stringLiteral, calloutArgs);
	:}
	;

CalloutArgs ::=
	CalloutArg:calloutArg
	{:
		RESULT = new ArrayList<AbstractCalloutArgument>();
		
		RESULT.add(calloutArg);
	:}
	|
	CalloutArgs:calloutArgs COMMA CalloutArg:calloutArg
	{:
		RESULT = new ArrayList<AbstractCalloutArgument>(calloutArgs);
		
		RESULT.add(calloutArg);
	:}
	;
	
CalloutArg ::=
	Expression:expression
	{:
		RESULT = new CalloutArgumentExpression(expression);
	:}
	|
	STRING_LITERAL:stringLiteral
	{:
		RESULT = new CalloutArgumentStringLiteral((String)stringLiteral);
	:}
	;

Location ::=
	IDENTIFIER:identifier
	{:
		RESULT = new IdentifierLocation(identifier);
	:}
	|
	IDENTIFIER:identifier LEFT_BRACKET Expression:expression RIGHT_BRACKET
	{:
		RESULT = new ArrayLocation(identifier, expression);
	:}
	;

Expressions ::=
	Expression:expression
	{:
		RESULT = new ArrayList<AbstractExpression>();
		
		RESULT.add(expression);
	:}
	|
	Expressions:expressions COMMA Expression:expression
	{:
		RESULT = new ArrayList<AbstractExpression>(expressions);
		
		RESULT.add(expression);
	:}
	;

Expression ::=
	Location:location
	{:
		RESULT = new LocationExpression(location);
	:}
	|
	MethodCall:methodCall
	{:
		RESULT = new MethodCallExpression(methodCall);
	:}
	|
	Literal:literal
	{:
		RESULT = new LiteralExpression(literal);
	:}
	|
	Expression:left BinaryOperator:operator Expression:right
	{:
		RESULT = new BinaryOperationExpression(left, operator, right);
	:}
	|
	MINUS Expression:expression
	{:
		RESULT = new MinusExpression(expression);
	:}
	|
	NOT Expression:expression
	{:
		RESULT = new NegationExpression(expression);
	:}
	|
	LEFT_PARENTHESIS Expression:expression RIGHT_PARENTHESIS
	{:
		RESULT = expression;
	:}
	;

BinaryOperator ::=
	ArithmeticOperator:operator
	{:
		RESULT = operator;
	:}
	|
	RelationOperator:operator
	{:
		RESULT = operator;
	:}
	|
	EqualityOperator:operator
	{:
		RESULT = operator;
	:}
	|
	ConditionalOperator:operator
	{:
		RESULT = operator;
	:}
	;

ArithmeticOperator ::=
	PLUS
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	MINUS
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	TIMES
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	DIVIDE
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	MODULO
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	ARITHMETIC_SHIFT_LEFT
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	ARITHMETIC_SHIFT_RIGHT
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	BITWISE_ROTATE_RIGHT
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	;

RelationOperator ::=
	LESS
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	GREATER
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	LESS_OR_EQUAL
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	GREATER_OR_EQUAL
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	;
	
EqualityOperator ::=
	EQUAL
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	NOT_EQUAL
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	;

ConditionalOperator ::=
	AND
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	|
	OR
	{:
		RESULT = ((DecafToken) this.getStackTop()).getInputString();
	:}
	;
	
Literal ::=
	INT_LITERAL:representation
	{:
		if (representation.startsWith("0x")) {
			RESULT = new IntLiteral(Integer.parseInt(representation.substring(2), 16));
		} else {
			RESULT = new IntLiteral(Integer.parseInt(representation));
		}
	:}
	|
	BOOLEAN_LITERAL:value
	{:
		RESULT = new BooleanLiteral(value);
	:}
	|
	CHAR_LITERAL:value
	{:
		RESULT = new CharLiteral(value);
	:}
	;
